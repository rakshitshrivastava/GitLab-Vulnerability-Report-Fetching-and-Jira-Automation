import requests
import csv
import time
from dotenv import load_dotenv
import os
import logging

# Load environment variables from .env file
load_dotenv()

PRIVATE_TOKEN = os.getenv('PRIVATE_TOKEN')
GROUP_ID = os.getenv('GROUP_ID')
URL = os.getenv('URL')

def create_vulnerability_export(project_id, headers, separate_files):
    create_export_url = f"https://gitlab.com/api/v4/security/projects/{project_id}/vulnerability_exports"
    try:
        create_export_response = requests.post(create_export_url, headers=headers)
        create_export_response.raise_for_status()
        export_id = create_export_response.json()["id"]
        logging.info(f"Vulnerability export created successfully. Export ID: {export_id}")
        time.sleep(1)
        download_vulnerability_export(export_id, headers, separate_files)
    except requests.RequestException as e:
        logging.error(f"Failed to create vulnerability export: {e}")

def download_vulnerability_export(export_id, headers, separate_files, max_retries=5):
    filename = f"vulnerability_export_{export_id}.csv" if separate_files else "vulnerability_export_all.csv"
    download_url = f"https://gitlab.com/api/v4/security/vulnerability_exports/{export_id}/download"
    
    for attempt in range(max_retries):
        try:
            download_response = requests.get(download_url, headers=headers)
            download_response.raise_for_status()
            with open(filename, "wb") as file:
                file.write(download_response.content)
            logging.info(f"Vulnerability export downloaded successfully. Saved as {filename}")
            process_vulnerability_export(filename, headers)
            break
        except requests.HTTPError as e:
            if download_response.status_code == 404 and attempt < max_retries - 1:
                logging.warning(f"Download attempt {attempt + 1} failed. Retrying...")
                time.sleep(2)
            else:
                logging.error(f"Failed to download vulnerability export: {e}")
                break

def process_vulnerability_export(filename, headers):
    with open(filename, 'r') as file:
        reader = csv.DictReader(file)
        fieldnames = reader.fieldnames
        if "gitlink" not in fieldnames:
            fieldnames.append("gitlink")
        if "solution" not in fieldnames:
            fieldnames.append("solution")
        rows = list(reader)
    
    for row in rows:
        vulnerability_id = row["Full Path"].split('/')[-1]
        gitlink = f"https://gitlab.com/{row['Full Path'].replace('/', '/-/security/vulnerabilities/')}"
        solution = fetch_solution(vulnerability_id, headers)
        row["gitlink"] = gitlink
        row["solution"] = solution
        logging.info(f"Vulnerability ID: {vulnerability_id}, Gitlink: {gitlink}, Solution: {solution}")

    with open(filename, 'w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(rows)

def fetch_solution(vulnerability_id, headers):
    solution_url = f"https://gitlab.com/api/v4/vulnerabilities/{vulnerability_id}"
    try:
        solution_response = requests.get(solution_url, headers=headers)
        solution_response.raise_for_status()
        return solution_response.json().get("finding", {}).get("solution", "")
    except requests.RequestException as e:
        logging.error(f"Failed to fetch solution for vulnerability ID {vulnerability_id}: {e}")
        return ""

def get_gitlab_projects(headers, group_id):
    url = f"https://gitlab.com/api/v4/groups/{group_id}/projects"
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        logging.error(f"Failed to fetch projects: {e}")
        return []

def main():
    headers = {
        "PRIVATE-TOKEN": PRIVATE_TOKEN
    }

    projects = get_gitlab_projects(headers, GROUP_ID)
    if not projects:
        return

    for index, project in enumerate(projects, 1):
        logging.info(f"{index}. ID: {project['id']}, Name: {project['name']}")
        logging.info("="*50)

    project_index = input("Enter project index to fetch vulnerability report (1, 2, 3, ...) or 'all' for all projects: ")
    separate_files = input("Create separate files for each project (y/n)? ").lower() == 'y'

    if project_index.lower() == 'all':
        for project in projects:
            create_vulnerability_export(project["id"], headers, separate_files)
    else:
        try:
            project_id = projects[int(project_index)-1]["id"]
            create_vulnerability_export(project_id, headers, separate_files)
        except (ValueError, IndexError):
            logging.error("Invalid project index.")

if __name__ == "__main__":
    main()
